<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Un pied à l'étrier</title>
    <style>
        body {
            background-color: antiquewhite;
        }
    </style>
</head>
<body>
    <div style="display: flex; gap: 20px; align-items: flex-start;">    
        <canvas id="my_canvas"></canvas>
    </div>
    <script>
        class Ant {
            constructor(){
                this.position = {x: 9, y: 9};
                this.objectif = {x: 9, y: 9};
                this.speed = 30;
            }
            move(fps, grid){

                let direction = Math.atan2(this.objectif.y-this.position.y , this.objectif.x-this.position.x);
                let dx = Math.cos(direction); // cos(0) = 1 ; cos(pi) = -1 ; cos(pi/2) = 0.
                let dy = Math.sin(direction); // sin(0) = 0 ; sin(pi) = 0 ; sin(pi/2) = 1 ; -1 car canvas inverse l'axe Y.
                let nextX = this.position.x + dx * this.speed / fps; // On divise par les fps car la fonction est appelée selon un fps donné (#cellGrid/seconde).
                let nextY = this.position.y + dy * this.speed / fps;
                this.position.x = nextX;
                this.position.y = nextY;
            }
            NewObjectif(grid){
                let moves = [];
                let directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]; // haut, bas, gauche, droite
                for(let dir of directions) {
                    let newX = Math.round(this.position.x) + dir[0];
                    let newY = Math.round(this.position.y) + dir[1];
                    
                    if(newX >= 0 && newX < grid[0].length && newY >= 0 && newY < grid.length && grid[newY][newX] > 0) {
                        moves.push({x: newX, y: newY});
                    }
                }
                return moves[Math.floor(Math.random() * moves.length)];
            
            }
        }
        class Model {
            constructor() {
                this.grid = [
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1 ,1, 1, 0, 0, 0, 0],
                    [0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 2, 0],
                    [0, 2, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0],
                    [0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0],
                    [0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0],
                    [0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0],
                    [0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0 ,0 ,0 ,0],
                    [0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0 ,0 ,0],
                    [0, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 0, 0, 1, 0, 0 ,0 ,0],
                    [0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0],
                    [0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0],
                    [0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0],
                    [0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0],
                    [0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0],
                    [0, 1, 0, 1, 0 ,1, 0, 0, 1, 0, 1, 0, 1, 1, 2, 1, 1, 0],
                    [0, 1, 1, 1, 0, 2, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
                ];
                this.nbLines   = (this.grid).length; // Nombre d'éléments dans le tableau (nombre de lignes).
                this.nbColumns = (this.grid[0]).length; // Nombre de colonnes.

                this.positionEnd   = {x: 10, y: 10};
                this._startTime     = Date.now();
                this._lag           = 0;
                this._fps           = 300; // Frame rate.
                this._frameDuration = 1000 / this._fps;
                this._timer         = 1;

                // piere-antoine.gean@mines-ales.fr
                this.ants = [];
                for (let i = 0; i < 50; i++) {
                    this.ants.push(new Ant());
                }
            }

            bindDisplayFourmi(callback) {
                this.DisplayFourmi = callback;
            }
            
            Update = function() {
                let currentTime = Date.now();
                let deltaTime   = currentTime - this._startTime;
                this._lag += deltaTime;
                this._startTime = currentTime;
                this._timer += deltaTime;
                while (this._lag >= this._frameDuration) {
                    for (let i = 0; i < this.ants.length; i++) {
                        console.log(i);    
                        this.ants[i].move(this._fps, this.grid);  
                        this._lag -= this._frameDuration;
                        if (Math.round(this.ants[i].position.x) == this.ants[i].objectif.x && Math.round(this.ants[i].position.y) == this.ants[i].objectif.y) {
                            this.ants[i].objectif = this.ants[i].NewObjectif(this.grid);
                        }
                    }
                    console.log("aaaa");
                    this.DisplayFourmi(this.ants, this.grid); 
                }
                requestAnimationFrame(this.Update.bind(this));
            
        }
    }
        class View {
          constructor() {
            this._cellSize  = 50; // La taille d'une cellule en pixel.
            this.canvas = document.getElementById('my_canvas');
            this.ctx = this.canvas.getContext('2d');
          }
          DisplayFourmi = function(ants, grid) {
            //console.log(position); 
            let _nbLines   = (grid).length;
            let _nbColumns = (grid[0]).length;
            this.canvas.width  = _nbColumns * this._cellSize;
            this.canvas.height = _nbLines * this._cellSize;
             // Récupération de la surface de dessin.
            for (let i_line = 0; i_line < _nbLines; i_line++) { // Boucles for pour afficher la grille.
                for (let i_col = 0; i_col < _nbColumns; i_col++) {
                    this.ctx.drawImage(FOUR_IMAGE, 160, 199, 37, 25, i_col * this._cellSize, i_line * this._cellSize, this._cellSize, this._cellSize);
                    this.ctx.drawImage(THREE_IMAGE, 128, 68, 32, 32, i_col * this._cellSize, i_line * this._cellSize, this._cellSize, this._cellSize);
                    if (grid[i_line][i_col] == 1) {
                        this.ctx.drawImage(THREE_IMAGE, 0, 127, 16, 16, i_col * this._cellSize, i_line * this._cellSize, this._cellSize, this._cellSize);
                    } else if (grid[i_line][i_col] == 0) {
                            this.ctx.drawImage(TWO_IMAGE, 156, 190, 38, 32, i_col * this._cellSize, i_line * this._cellSize, this._cellSize, this._cellSize);
                    } else if (grid[i_line][i_col] == 2) {
                            this.ctx.drawImage(HEXTILES_IMAGE, 98,487, 26, 20, i_col * this._cellSize, i_line * this._cellSize, this._cellSize, this._cellSize);
                    } else if (grid[i_line][i_col] == 3) {
                            this.ctx.drawImage(HEXTILES_IMAGE, 99,646, 25, 26, i_col * this._cellSize, i_line * this._cellSize, this._cellSize, this._cellSize);
                    }  
                }
            }
            for (let i = 0; i < ants.length; i++) {
            this.ctx.drawImage(FIVE_IMAGE, 27,15, 79, 101,ants[i].position.x*this._cellSize, ants[i].position.y*this._cellSize, this._cellSize, this._cellSize);
            }
        }
          
        }

        class Controller {
            constructor(model, view) {
              this.model = model
              this.view = view
              this.bindDisplayFourmi = this.bindDisplayFourmi.bind(this);
              this.model.bindDisplayFourmi(this.bindDisplayFourmi);     
              this.model.Update()
            }
            bindDisplayCNF (cnf_value) {
                this.view.Display(cnf_value);
            }
            bindDisplayFourmi (position,grid) {
                this.view.DisplayFourmi(position,grid);
            }
        }

        const HEXTILES_IMAGE = new Image();
        HEXTILES_IMAGE.src = 'foodAndColony.png';
        const TWO_IMAGE = new Image();
        TWO_IMAGE.src = 'tree.png';
        const THREE_IMAGE = new Image();
        THREE_IMAGE.src = 'grass.png';
        const FOUR_IMAGE = new Image();
        FOUR_IMAGE.src = 'shadow.png';
        const FIVE_IMAGE = new Image();
        FIVE_IMAGE.src = 'among.jpg';
        Promise.all([
            new Promise( (resolve) => {HEXTILES_IMAGE.addEventListener('load', () => { resolve();}); }),
            new Promise( (resolve) => {TWO_IMAGE.addEventListener('load', () => { resolve();}); }),
            new Promise( (resolve) => {THREE_IMAGE.addEventListener('load', () => { resolve();}); }),
            new Promise( (resolve) => {FOUR_IMAGE.addEventListener('load', () => { resolve();}); }),
            new Promise( (resolve) => {FIVE_IMAGE.addEventListener('load', () => { resolve();}); }),
        ])
        .then(() => {   
            const app = new Controller(new Model(), new View())

        });      
    </script>
    
</body>
</html>